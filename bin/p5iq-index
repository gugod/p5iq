#!/usr/bin/env perl

use v5.18;
use warnings;
use FindBin;
use lib "${FindBin::Bin}/../lib";

use P5iq;

use PPI;
use File::Next;
use JSON qw(to_json);
use Elastijk;

sub scan_this_dir {
    my ($srcdir, $cb) = @_;
    my $files = File::Next::files({ file_filter => sub { / \.p[ml] $/x } }, $srcdir);
    while ( defined ( my $file = $files->() ) ) {
        $cb->($file);
    }
}

sub index_perl_source_code {
    my ($file) = @_;

    say "<<< $file";
    my $document = PPI::Document->new($file) or return;

    for my $statement (@{ $document->find('PPI::Statement') }) {
        my $doc = {
            location      => join("\0",$file, $statement->line_number, $statement->column_number),
            content       => $statement->content,
            class         => $statement->class,
            token_content => [],
            token_class   => [],
            tags          => [],
        };
        for my $c ($statement->schildren) {
            push @{$doc->{token_content}}, $c->content;
            push @{$doc->{token_class}}, $c->class;
        }
        index_this( $doc );
    }
}

sub init_es_object {
    my $es = P5iq->es;

    unless ($es->exists( index => "p5iq" )) {
        say '# create index "p5iq"';
        my ($status, $res) = $es->put(
            index => "p5iq",
            body  => {
                mappings => {
                    p5_node => {
                        properties => {
                            location    => { "type" => "string", "index" => "not_analyzed" },
                            class         => { "type" => "string", "index" => "not_analyzed" },
                            content       => { "type" => "string" },
                            token_content => { "type" => "string" },
                            token_class   => { "type" => "string","index" => "not_analyzed" },
                            tags          => { "type" => "string","index" => "not_analyzed" },
                        }
                    },
                }
            }
        );
        say "CREATE INDEX: $status ".to_json($res);
    }

    return $es;
}

sub index_this {
    state $es = init_es_object();
    state @buffer;
    my $doc = shift;
    push @buffer, $doc if $doc;
    if (@buffer > 500 || !$doc) {
        $es->bulk(
            index => "p5iq",
            type  => "p5_node",
            body => [ map { ({index => {}}, $_) } @buffer ]
        );
        @buffer = ();
    }
}

my $srcdir = shift or die "required";
scan_this_dir($srcdir, \&index_perl_source_code );
index_this();

