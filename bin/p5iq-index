#!/usr/bin/env perl

use v5.18;
use warnings;

use PPI;
use PPI::Find;

use File::Next;
use JSON qw(to_json);
use Elastijk;

sub scan_this_dir {
    my ($srcdir, $cb) = @_;
    my $files = File::Next::files({ file_filter => sub { / \.p[ml] $/x } }, $srcdir);
    while ( defined ( my $file = $files->() ) ) {
        $cb->($file);
    }
}

sub index_perl_source_code {
    my ($file) = @_;

    my $document = PPI::Document->new($file) or return;
    my @statements = PPI::Find->new(
        sub {
            my ($this, $top) = @_;
            return 1 if ($this->isa('PPI::Statement'));
            return 0;
        }
    )->in($document);

    for my $statement (  @statements  ) {
        for my $token ( $statement->tokens ) {
            next unless $token->significant;

            my $doc = {
                statement_location => $file . "\0" . $statement->line_number . "\0" . $statement->column_number,
                content              => $token->content,
                type                 => $token->class,
            };
            index_this($doc);
        }
    }
}

sub init_es_object {
    my $es = Elastijk->new(
        host => "localhost",
        port => "9200",
    );

    unless ($es->exists( index => "p5iq" )) {
        say '# create index "p5iq"';
        my ($status, $res) = $es->put(
            index => "p5iq",
            body  => {
                mappings => {
                    ppi_token => {
                        properties => {
                            statement_location   => { "type" => "string", "index" => "not_analyzed" },
                            type                 => { "type" => "string", "index" => "not_analyzed" },
                            content              => { "type" => "string" },
                            # file                 => { "type" => "string", "index" => "not_analyzed" },
                            # start_offset         => { "type" => "long" },
                            # stop_offset          => { "type" => "long" },
                            # line_number          => { "type" => "long" },
                            # column_number        => { "type" => "long" },
                            # visual_column_number => { "type" => "long" },
                            # logical_line_number  => { "type" => "long" },
                        }
                    },
                }
            }
        );
        say "CREATE INDEX: $status $res";
    }

    return $es;
}

sub index_this {
    state $es = init_es_object();

    my $doc = shift;
    $es->post(
        index => "p5iq",
        type  => "ppi_token",
        body   => $doc
    );
}

my $srcdir = shift or die "required";
scan_this_dir($srcdir, \&index_perl_source_code );
