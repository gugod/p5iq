#!/usr/bin/env perl

use v5.18;
use warnings;
use FindBin;
use lib "${FindBin::Bin}/../lib";

use P5iq;

use PPI;

use File::Next;
use File::Basename 'fileparse';
use JSON qw(to_json);
use Elastijk;

sub scan_this_dir {
    my ($srcdir, $cb) = @_;
    my $files = File::Next::files({ file_filter => sub { / \.p[ml] $/x } }, $srcdir);
    while ( defined ( my $file = $files->() ) ) {
        $cb->($file);
    }
}

sub index_perl_source_code {
    my ($file) = @_;
    say "<<< $file";
    my $ppi_doc = PPI::Document->new($file) or return;

    my ($name,$path) = fileparse($file);
    my @features = P5iq::analyze_for_index($ppi_doc);

    for (@features) {
        $_->{file} = $file;
    }
    say ">>> " . scalar(@features) . " features";

    delete_by_file($file);
    index_these(\@features);
}

sub es_object {
    state $es;

    unless ($es) {
        $es = P5iq->es;
        unless ($es->exists( index => "p5iq" )) {
            say '# create index "p5iq"';
            my ($status, $res) = $es->put(
                index => "p5iq",
                body  => {
                    mappings => {
                        p5_node => {
                            properties => {
                                file          => { "type" => "string", "index" => "not_analyzed" },
                                line_number   => { "type" => "integer" },
                                row_number    => { "type" => "integer" },
                                class         => { "type" => "string", "index" => "not_analyzed" },
                                content       => { "type" => "string" },
                                token_content => { "type" => "string" },
                                token_class   => { "type" => "string","index" => "not_analyzed" },
                                tags          => { "type" => "string","index" => "not_analyzed" },
                            }
                        },
                    }
                }
            );
            say "CREATE INDEX: $status ".to_json($res);
        }
    }

    return $es;
}

sub delete_by_file {
    state $es = es_object();
    my $file = shift;
    $es->delete(
        index => "p5iq",
        command => "_query",
        body => { query => { term => { file => $file }}}
    );
}

sub index_these {
    state $es = es_object();
    my $features = shift;
    $es->bulk(
        index => "p5iq",
        type  => "p5_node",
        body => [ map { ({index => {}}, $_) } @$features ]
    );
}

for my $srcdir (@ARGV) {
    scan_this_dir($srcdir, \&index_perl_source_code );
}

say "### optimizing index";
es_object->post( command => "_optimize", uri_param => {  max_num_segments  => 1 } );
